(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{170:function(a,t,r){"use strict";r.r(t);var e=r(0),v=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("hr"),a._v(" "),r("h2",{attrs:{id:"单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 单一职责原则")]),a._v(" "),r("pre",[r("code",[a._v('每个类应该只有一个职责，对外只能提供一种功能，引起类变化的原因只有一个,也就是常说的"高内聚，低耦合"\n')])]),a._v(" "),r("hr"),a._v(" "),r("h2",{attrs:{id:"开-闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开-闭原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 开-闭原则")]),a._v(" "),r("pre",[r("code",[a._v("一个对象对扩展开放，对修改关闭，对类的改动是通过增加代码进行，而不是修改已有的代码。\n将可变的内容通过抽象和多态抽取出来，从而使抽象的部分相对稳定。\n")])]),a._v(" "),r("ul",[r("li",[a._v("一种可变性不应当散落在代码的很多角落里，应当被封装到一个对象里，同一种可变性的不同表象意味着同一个继承结构中的具体子类")]),a._v(" "),r("li",[a._v("一种可变性不应当与另一种可变性混合在一起")])]),a._v(" "),r("h2",{attrs:{id:"里氏替换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 里氏替换原则")]),a._v(" "),r("pre",[r("code",[a._v('任何父类出现的地方都可以用其子类去替换。\n实现"开-闭"原则的关键步骤就是抽象化，所以里氏替换原则是对实现抽象化的及具体步骤的规范。\n')])]),a._v(" "),r("h2",{attrs:{id:"依赖倒转原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 依赖倒转原则")]),a._v(" "),r("pre",[r("code",[a._v("依赖于抽象不依赖于具体实现。\n类的使用或依赖其他的类不应该使用它们的具体类，例如:Map map = new HashMap()。\n")])]),a._v(" "),r("ul",[r("li",[a._v("第一种表述： 抽象不应依赖于细节，细节应该依赖于抽象。")]),a._v(" "),r("li",[a._v("第二种表述： 要针对接口编程，不要针对实现编程。"),r("br"),a._v("\n  针对接口编程的意思就是说，应当使用java接口和抽象java类进行变量的类型声明，参数的类型声明，方法的返还类型声明以及数据类型转换等。"),r("br"),a._v("\n  不要针对实现编程的意思就是说，不应当使用具体的java类进行变量的类型声明，参数的类型声明，方法的返还类型声明以及数据类型转换等。")]),a._v(" "),r("li",[a._v("如果一个具体类发生变化的可能性非常小，使用具体耦合会更好。")])]),a._v(" "),r("h2",{attrs:{id:"接口分离原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口分离原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 接口分离原则")]),a._v(" "),r("pre",[r("code",[a._v("一个接口不需要提供很多额外的功能，不能把所有的操作封装到一个接口中。\n不应该强迫程序依赖他们不需要使用的方法，抽象类是单继承，接口是可以多实现的。\n")])]),a._v(" "),r("h2",{attrs:{id:"迪米特原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迪米特原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 迪米特原则")]),a._v(" "),r("pre",[r("code",[a._v("一个对象应该对其他对象尽可能少的了解，降低对象之间的耦合；尽可能少的和其他实体发生相互作用。\n在模块之间应该只通过接口编程，而不理会各个模块之间的具体实现。 \n")])]),a._v(" "),r("ul",[r("li",[a._v("在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及")]),a._v(" "),r("li",[a._v("在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限")]),a._v(" "),r("li",[a._v("在类的设计上，只要有可能，一个类型应当设计成不变类")]),a._v(" "),r("li",[a._v("在对其他类的引用上，一个对象对其他对象的引用应当降到最低")])])])}],!1,null,null,null);t.default=v.exports}}]);